# -*- coding: utf-8 -*-
"""Copy of ML_preprocess.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pr1-ZAaDJ6GAovNdbytDONXCnOgEgWCw
"""

##############  XGBOOST ####
import pandas as pd
import numpy as np
import xgboost
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_validate
from sklearn.metrics import brier_score_loss


from sklearn.model_selection import train_test_split, StratifiedShuffleSplit, cross_val_score
from sklearn.metrics import roc_curve, auc, roc_auc_score, accuracy_score
from sklearn.model_selection import GridSearchCV, RandomizedSearchCV
from sklearn.metrics import mean_squared_error



train = pd.read_csv('train.csv', sep=',')

test = pd.read_csv('test.csv', sep=',')

tr =pd.DataFrame(train)

test1 = pd.DataFrame(test)

# splitting features and outcome and creating train and test datasets
te = test1.iloc[:,1:7]


x = tr.iloc[:,2:8]


y = np.array(tr.iloc[:,1:2]).ravel()

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.10, random_state=50)


#building XGBoost model with hyperparameters
XGmodel = xgboost.XGBClassifier(max_depth=40, learning_rate=0.01, n_estimators=120, objective='binary:logistic', reg_alpha=1.8, reg_lambda=1)

# kfold cross validation
kfold = KFold(n_splits=5)
result = cross_validate(XGmodel, X_train, y_train, cv=kfold,scoring= ['accuracy','roc_auc','brier_score_loss'])
#print(result)


print("Accuracy={:.3f}".format(result['test_accuracy'].mean()))
print("Roc={:.3f}".format(result['test_roc_auc'].mean()))
print("Brier Score={:.3f}".format(result['test_brier_score_loss'].mean()))


a= y_test.reshape(y_test.size,1)

y_new = np.hstack((1 - a,a))

XGmodel.fit(X_train,y_train)

# predicting probabilites 
pred = XGmodel.predict_proba(X_test)

pred1 = XGmodel.predict(X_test)

# getting metrics
acc = accuracy_score(y_test ,pred1)

roc = roc_auc_score(y_new, pred)

brier_score = brier_score_loss(y_test ,pred1)

print("Accuracy={:.3f}".format(acc))
print("Roc={:.3f}".format(roc))
print("Brier Score={:.3f}".format(brier_score))

# fitting model on train data and predicting probabilties for test data
XGmodel.fit(x,y)

pred = XGmodel.predict_proba(te)

bot_pred= pred[:,1]

print("XGBoost output")

print(pred[:,1])



Submission = pd.read_csv('test.csv', sep=',')

Submission['prediction'] = bot_pred

Submission[['bidder_id','prediction']].to_csv('submission.csv', sep=',', header=True, index=False)

########### Random FOrest ##

import pandas as pd
import numpy as np
import xgboost
from sklearn.model_selection import KFold

from sklearn.model_selection import cross_validate

from sklearn.model_selection import train_test_split, StratifiedShuffleSplit, cross_val_score
from sklearn.metrics import roc_curve, auc, roc_auc_score, accuracy_score
from sklearn.model_selection import GridSearchCV, RandomizedSearchCV
from sklearn.metrics import brier_score_loss

from sklearn.ensemble import RandomForestClassifier


train = pd.read_csv('train.csv', sep=',')

test = pd.read_csv('test.csv', sep=',')


# preprocessing
train = train.dropna()
test = test.dropna()

tr =pd.DataFrame(train)
test1 = pd.DataFrame(test)
# splitting features and outcome and creating train and test datasets
te = test1.iloc[:,1:7]




x = tr.iloc[:,2:8]


y = np.array(tr.iloc[:,1:2]).ravel()

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.10, random_state=50)


# building RF model
RFmodel= RandomForestClassifier(max_depth=20, n_estimators =120, bootstrap=False)
#kfold cross validation
kfold = KFold(n_splits=5)
result = cross_validate(RFmodel, X_train, y_train, cv=kfold,scoring= ['accuracy','roc_auc','brier_score_loss'])


print("Accuracy={:.3f}".format(result['test_accuracy'].mean()))
print("Roc={:.3f}".format(result['test_roc_auc'].mean()))
print("Brier Score={:.3f}".format(result['test_brier_score_loss'].mean()))


a= y_test.reshape(y_test.size,1)

y_new = np.hstack((1 - a,a))

RFmodel.fit(X_train,y_train)

# predicting probabilties and getting metrics
pred = RFmodel.predict_proba(X_test)
pred1 = XGmodel.predict(X_test)

brier_score = brier_score_loss(y_test ,pred1)

acc = accuracy_score(y_test ,pred1)

roc = roc_auc_score(y_new, pred)

brier_score = brier_score_loss(y_test ,pred1)


print("Accuracy={:.3f}".format(acc))
print("Roc={:.3f}".format(roc))

print("Brier Score={:.3f}".format(brier_score))




# fitting RF model on train and predicting for test

RFmodel.fit(x,y)

pred = RFmodel.predict_proba(te)
print("Random Forest output")

print(pred[:,1])

################# Neural Net #######


from keras.models import Sequential
from keras.layers import Dense,Dropout
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_curve, auc, roc_auc_score, accuracy_score
import tensorflow as tf
from keras import backend as bk
from sklearn.metrics import brier_score_loss

train = pd.read_csv('train.csv', sep=',')

test = pd.read_csv('test.csv', sep=',')


# preprocessing
train = train.dropna()
test = test.dropna()

tr =pd.DataFrame(train)
test1 = pd.DataFrame(test)

# splitting features and outcome and creating train and test datasets
te = test1.iloc[:,1:7]




x = tr.iloc[:,2:8]


y = np.array(tr.iloc[:,1:2]).ravel()

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.10, random_state=50)

# method for calculating roc

def roc(y_true,y_pred):
  roc=tf.metrics.auc(y_true,y_pred)[1]
  bk.get_session().run(tf.local_variables_initializer())
  return roc


# creating sequential deep learning model
seq = Sequential()
seq.add(Dense(4,input_dim=6,activation='relu'))
seq.add(Dense(4,activation='relu'))
seq.add(Dense(1,activation='sigmoid'))

seq.compile(loss='binary_crossentropy',optimizer='adam',metrics=['accuracy',roc])

seq.fit(X_train,y_train,validation_split=0.3,epochs=25,batch_size=10)


a= y_test.reshape(y_test.size,1)

y_new = np.hstack((1 - a,a))

pred1=seq.predict_classes(X_test).ravel()


# predicting probabilties
pred=seq.predict_proba(X_test).ravel()

# computing metrics
fpr,tpr,th = roc_curve(y_test,pred)

auc_score=auc(fpr,tpr)

acc = accuracy_score(y_test,pred1)

brier_score = brier_score_loss(y_test ,pred1)


print("Accuracy=",acc)

print("ROC=",auc_score)

print("Brier Score={:.3f}".format(brier_score))

# fitting model on train and predicting for test
seq.fit(x,y,validation_split=0.3,epochs=25,batch_size=10)


pred=seq.predict_proba(te)

print("Neural Net output")
print(pred)